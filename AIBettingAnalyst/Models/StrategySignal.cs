using AIBettingCore.Models;

namespace AIBettingAnalyst.Models;

/// <summary>
/// Represents a trading signal generated by an analysis strategy.
/// </summary>
public record StrategySignal
{
    /// <summary>
    /// Unique identifier for this signal.
    /// </summary>
    public string SignalId { get; init; } = Guid.NewGuid().ToString();
    
    /// <summary>
    /// Market identifier.
    /// </summary>
    public required string MarketId { get; init; }
    
    /// <summary>
    /// Strategy that generated this signal.
    /// </summary>
    public required string Strategy { get; init; }
    
    /// <summary>
    /// Signal type (e.g., "SCALP_LONG", "STEAM_MOVE", "GREEN_UP", "VALUE_BET").
    /// </summary>
    public required string SignalType { get; init; }
    
    /// <summary>
    /// Timestamp when signal was generated.
    /// </summary>
    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset.UtcNow;
    
    /// <summary>
    /// Confidence level (0.0 to 1.0).
    /// </summary>
    public double Confidence { get; init; }
    
    /// <summary>
    /// Expected return on investment (percentage).
    /// </summary>
    public double ExpectedROI { get; init; }
    
    /// <summary>
    /// Risk level (LOW, MEDIUM, HIGH).
    /// </summary>
    public RiskLevel Risk { get; init; }
    
    /// <summary>
    /// Selection to trade (can be null for multi-leg strategies).
    /// </summary>
    public SelectionSignal? PrimarySelection { get; init; }
    
    /// <summary>
    /// Secondary selection for hedge/arbitage (optional).
    /// </summary>
    public SelectionSignal? SecondarySelection { get; init; }
    
    /// <summary>
    /// Market context at signal generation time.
    /// </summary>
    public MarketContext MarketContext { get; init; } = new();
    
    /// <summary>
    /// Human-readable reason for signal generation.
    /// </summary>
    public string Reason { get; init; } = string.Empty;
    
    /// <summary>
    /// Additional strategy-specific data.
    /// </summary>
    public Dictionary<string, object> Metadata { get; init; } = new();
    
    /// <summary>
    /// Priority for signal execution (higher = more urgent).
    /// </summary>
    public int Priority { get; init; }
    
    /// <summary>
    /// Recommended action (BUY, SELL, HEDGE, CLOSE).
    /// </summary>
    public TradeAction Action { get; init; }
    
    /// <summary>
    /// Time window for signal validity (seconds).
    /// </summary>
    public int ValidityWindow { get; init; } = 60;
}

/// <summary>
/// Selection-specific signal details.
/// </summary>
public record SelectionSignal
{
    public required string SelectionId { get; init; }
    public required string SelectionName { get; init; }
    public decimal RecommendedOdds { get; init; }
    public decimal Stake { get; init; }
    public BetType BetType { get; init; }
    public decimal? StopLoss { get; init; }
    public decimal? TakeProfit { get; init; }
}

/// <summary>
/// Market context snapshot.
/// </summary>
public record MarketContext
{
    public decimal TotalMatched { get; init; }
    public int SecondsToStart { get; init; }
    public string EventName { get; init; } = string.Empty;
    public decimal MarketVolatility { get; init; }
    public decimal LiquidityScore { get; init; }
}

// Keep enums as-is (they can't be records)
/// <summary>
/// Risk level classification.
/// </summary>
public enum RiskLevel
{
    Low,
    Medium,
    High,
    VeryHigh
}

/// <summary>
/// Trading action type.
/// </summary>
public enum TradeAction
{
    Back,      // Buy/Long
    Lay,       // Sell/Short
    Hedge,     // Opposite position to lock profit
    Close,     // Close existing position
    Hold       // No action, monitor
}

/// <summary>
/// Bet type.
/// </summary>
public enum BetType
{
    Back,
    Lay
}
